% Решение задачи сопровождается построением заданной плоскости,
% наплавляющих векторов i j k и вектора нормали, который
% определяется в программном коде в зависимости от заданной плоскости


% Ввод данных
% x1 x2 y3 - заданные координаты равные 0, потому пользователь должен
% ввести лишь оставшиеся

Ax = 0;
Ay = input('Введите координату Ay = ');
Az = input('Введите координату Az = ');

Bx = 0;
By = input('Введите координату By = ');
Bz = input('Введите координату Bz = ');

Cx = input('Введите координату Cx = ');
Cy = 0;
Cz = input('Введите координату Cz = ');

% Определение векторов для построения плоскости 
% для определения уравнения плоскости нужно составить матрицу из 
% координат 3х векторов
syms x y z
AM = [x-Ax y-Ay z-Az];
AB = [Bx-Ax By-Ay Bz-Az];
AC = [Cx-Ax Cy-Ay Cz-Az];
% Составление уравнения плоскости, т.е подсчет определителя == 0
f = det([AM(1) AM(2) AM(3); AB(1) AB(2) AB(3); AC(1) AC(2) AC(3)]) == 0;
% Выражение z из уравнения
z1 = solve(f, z);
% Построение плоскости в диапазоне от -10 до 10
fsurf(z1, [-10 10 -10 10]);

% Для определения координат вектора нормали пересчитываем определитель
% но без приравнивания его к 0
syms x y z
AM = [x-Ax y-Ay z-Az];
AB = [Bx-Ax By-Ay Bz-Az];
AC = [Cx-Ax Cy-Ay Cz-Az];
f1 = det([AM(1) AM(2) AM(3); AB(1) AB(2) AB(3); AC(1) AC(2) AC(3)]);

% Находим коэффиценты при x y z - это и есть координаты нашего вектора
% нормали плоскости
x_coeffs_list = coeffs(f1, x);
if (length(x_coeffs_list) == 2)
    x_coeff = x_coeffs_list(2);
else
    x_coeff = 0;
end

y_coeffs_list = coeffs(f1, y);
if (length(y_coeffs_list) == 2)
    y_coeff = y_coeffs_list(2);
else
    y_coeff = 0;
end

z_coeffs_list = coeffs(f1, z);
if (length(z_coeffs_list) == 2)
    z_coeff = z_coeffs_list(2);
else
    z_coeff = 0;
end

% Построение направляющих векторов i j k для наглядности
hold on
quiver3(0,0,0,10,0,0)
quiver3(0,0,0,0,10,0)
quiver3(0,0,0,0,0,10)

% Построение вектора нормали из точки O (0, 0, 0)
quiver3(0,0,0, x_coeff, y_coeff, z_coeff, 'color','black')

view(100,15)
axis equal
hold off

% На данном этапе зная координаты вектора нормали нам нужно
% найти углы которые он составляет с осями x и y для нахождения 
% искомых уклонов плоскости

% из координат векторов можно найти косинус угла между ними по формуле
% cos α = 	a·b / |a|·|b|

% найдем скалярное произведение векторов (1 0 0) и нашей нормали  
scal_mul1 = dot([1 0 0], [x_coeff y_coeff z_coeff]);
% теперь найдем произведение модулей векторов
modules_mul1 = (x_coeff^2 + y_coeff^2 + z_coeff^2)^(1/2) * (1)^(1/2);
% искомый косинус =
cos_x = scal_mul1 / modules_mul1;
% отсюда найдем тангенс уклона нормали относительно оси х
tan_x = tan(acos(cos_x));

% Аналогично поступаем с осью у, подменяя вектор (1 0 0) на (0 1 0)
scal_mul2 = dot([0 1 0], [x_coeff y_coeff z_coeff]);
modules_mul2 = (x_coeff^2 + y_coeff^2 + z_coeff^2)^(1/2) * (1)^(1/2);
cos_y = scal_mul2 / modules_mul2;
tan_y = tan(acos(cos_y));

% Таким образом мы получили искомые тангенсы уклона нормали плоскости 
% относительно осей х и у

% Вывод ответа
fprintf('ԑ(x) = %f\nԑ(y) = %f\n', tan_x, tan_y)
